# 基本数据类型相关知识点

## 八种基本数据类型

|         | 字节  | 范围            | 类型         | 包装数据类型 |
| ------- | ----- | --------------- | ------------ | ------------ |
| byte    | 1     | -2^8到2^8-1     | 整数         | Byte         |
| short   | 2     |                 | 整数         | Short        |
| int     | 4     |                 | 整数         | Integer      |
| long    | 8     |                 | 整数         | Long         |
| float   | 4     | float a = 1.0f  | 单精度浮点数 | Float        |
| double  | 8     | double b = 1.0L | 双精度浮点数 | Double       |
| char    | 2     |                 | 字符         | Character    |
| boolean | 1比特 |                 | 布尔         | Boolean      |

涉及的知识点

### 包装类自动拆箱与装箱

Java自动将基本数据类型和包装类进行转换, 基本数据类型的数据存储在栈中，而包装类型的对象存储在堆中，基本数据类型的操作比包装类型的操作更加高效。

```java
//装箱
Integer a = 1;
//开箱
int a = new Integer(1);
```

## String数据类型

#### String不可变

String是一个对象且是一个不可变对象, 即任何对于 String 对象的操作不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。

```java
public final class String{
    private final char value[];
}
```

不可变的原因

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变

为什么要设计要设计成不可变对象？ **线程安全**

#### 字符串常量池

创建字符串的两种方法,第一种在创建字符串时，会检查字符串常量池是否存在相同的字符串，若有则将引用返回给s，若没有，则在常量池中创建一个新字符串对象，并将改对象的地址返回。字符串常量池在jdk1.7后存放在堆

第二种方法通过new关键字创建时，会在字符串常量池中创建一个”aa”对象。然后执行new String时会在堆中创建一个“aa”的对象，然后把s的引用指向堆中的这个“aa”对象。

```java
String s1 = "aa"
String s2 = new String("aa");
```

intern方法

```
//调用intern()方法之后把字符串对象加入常量池中
String b = new String("ab"); 
String c=b.intern();
```

#### StringBuilder与StringBuffer

我们每次对`String`的操作都会在内存中产生一个新的String对象，这样不仅效率低而且占用内存空间，所以引用两种对字符串操作的类型

StringBuilder

```java
//StringBuilder是一个可变的字符串类型,不保证线程同步,所以在单线程环境下比StringBuffer效率高

//在new StringBuilder时如果没有传参，则调用父类方法构造一个其中没有字符且初始容量为 16 个字符的字符串构建器
public StringBuilder() {super(16);}

//示例
StringBuilder str = new StringBuilder("string");

//append方法,append 方法将这些字符添加到字符串的末尾
str.append("123")
    
//insert方法，在指定位置添加字符 s123tring
str.insert(1,"123") 
```

StringBuffer

支持线程安全，方法与StringBuilder相同，实现线程安全的方法是每个方法都添加了sychronized关键字

#### 比较（==与equals）

==如果是基本数据类型，比较的是存储的值，如果是引用数据类型，则比较的是所指向对象的地址值是否相等（是否是同一个对象）。

equals是Object的方法，用来比较两个对象的地址值是否相等。如果没有重写equals则与==相等。诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

```java
  public boolean equals(Object obj) {
        return (this == obj);
    }

String a = new String("aa");
String b = "aa"
System.out.println(a == b) //比较的地址，false
System.out.println(a.equals(b)) // ture，重写了比较的是内容
String c = "aa"
System.out.println(b == c)  //都在常量池，true
```

